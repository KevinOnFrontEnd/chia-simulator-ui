/* tslint:disable */
/* eslint-disable */
export function encodeOffer(spendBundle: SpendBundle): string;
export function decodeOffer(offer: string): SpendBundle;
export function standardPuzzleHash(syntheticKey: PublicKey): Uint8Array;
export function catPuzzleHash(assetId: Uint8Array, innerPuzzleHash: Uint8Array): Uint8Array;
export function fromHex(value: string): Uint8Array;
export function toHex(value: Uint8Array): string;
export function bytesEqual(lhs: Uint8Array, rhs: Uint8Array): boolean;
export function treeHashAtom(atom: Uint8Array): Uint8Array;
export function treeHashPair(first: Uint8Array, rest: Uint8Array): Uint8Array;
export function sha256(value: Uint8Array): Uint8Array;
export function curryTreeHash(program: Uint8Array, args: Array<any>): Uint8Array;
export function generateBytes(bytes: number): Uint8Array;
export function mOfNHash(config: MemberConfig, required: number, items: Array<any>): Uint8Array;
export function k1MemberHash(config: MemberConfig, publicKey: K1PublicKey, fastForward: boolean): Uint8Array;
export function r1MemberHash(config: MemberConfig, publicKey: R1PublicKey, fastForward: boolean): Uint8Array;
export function blsMemberHash(config: MemberConfig, publicKey: PublicKey): Uint8Array;
export function passkeyMemberHash(config: MemberConfig, publicKey: R1PublicKey, fastForward: boolean): Uint8Array;
export function singletonMemberHash(config: MemberConfig, launcherId: Uint8Array): Uint8Array;
export function fixedMemberHash(config: MemberConfig, fixedPuzzleHash: Uint8Array): Uint8Array;
export function customMemberHash(config: MemberConfig, innerHash: Uint8Array): Uint8Array;
export function timelockRestriction(timelock: bigint): Restriction;
export function force1Of2Restriction(leftSideSubtreeHash: Uint8Array, nonce: number, memberValidatorListHash: Uint8Array, delegatedPuzzleValidatorListHash: Uint8Array): Restriction;
export function preventConditionOpcodeRestriction(conditionOpcode: number): Restriction;
export function preventMultipleCreateCoinsRestriction(): Restriction;
export function preventVaultSideEffectsRestriction(): Restriction[];
export function wrappedDelegatedPuzzleHash(restrictions: Restriction[], delegatedPuzzleHash: Uint8Array): Uint8Array;
export enum RestrictionKind {
  MemberCondition = 0,
  DelegatedPuzzleHash = 1,
  DelegatedPuzzleWrapper = 2,
}
export class AdditionsAndRemovalsResponse {
  free(): void;
  constructor(additions: CoinRecord[] | null | undefined, removals: CoinRecord[] | null | undefined, error: string | null | undefined, success: boolean);
  get additions(): CoinRecord[] | undefined;
  set additions(value: CoinRecord[] | null | undefined);
  get removals(): CoinRecord[] | undefined;
  set removals(value: CoinRecord[] | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class Address {
  free(): void;
  encode(): string;
  static decode(address: string): Address;
  constructor(puzzleHash: Uint8Array, prefix: string);
  puzzleHash: Uint8Array;
  prefix: string;
}
export class AggSigAmount {
  free(): void;
  constructor(publicKey: PublicKey, message: Uint8Array);
  publicKey: PublicKey;
  message: Uint8Array;
}
export class AggSigMe {
  free(): void;
  constructor(publicKey: PublicKey, message: Uint8Array);
  publicKey: PublicKey;
  message: Uint8Array;
}
export class AggSigParent {
  free(): void;
  constructor(publicKey: PublicKey, message: Uint8Array);
  publicKey: PublicKey;
  message: Uint8Array;
}
export class AggSigParentAmount {
  free(): void;
  constructor(publicKey: PublicKey, message: Uint8Array);
  publicKey: PublicKey;
  message: Uint8Array;
}
export class AggSigParentPuzzle {
  free(): void;
  constructor(publicKey: PublicKey, message: Uint8Array);
  publicKey: PublicKey;
  message: Uint8Array;
}
export class AggSigPuzzle {
  free(): void;
  constructor(publicKey: PublicKey, message: Uint8Array);
  publicKey: PublicKey;
  message: Uint8Array;
}
export class AggSigPuzzleAmount {
  free(): void;
  constructor(publicKey: PublicKey, message: Uint8Array);
  publicKey: PublicKey;
  message: Uint8Array;
}
export class AggSigUnsafe {
  free(): void;
  constructor(publicKey: PublicKey, message: Uint8Array);
  publicKey: PublicKey;
  message: Uint8Array;
}
export class AssertBeforeHeightAbsolute {
  free(): void;
  constructor(height: number);
  height: number;
}
export class AssertBeforeHeightRelative {
  free(): void;
  constructor(height: number);
  height: number;
}
export class AssertBeforeSecondsAbsolute {
  free(): void;
  constructor(seconds: bigint);
  seconds: bigint;
}
export class AssertBeforeSecondsRelative {
  free(): void;
  constructor(seconds: bigint);
  seconds: bigint;
}
export class AssertCoinAnnouncement {
  free(): void;
  constructor(announcementId: Uint8Array);
  announcementId: Uint8Array;
}
export class AssertConcurrentPuzzle {
  free(): void;
  constructor(puzzleHash: Uint8Array);
  puzzleHash: Uint8Array;
}
export class AssertConcurrentSpend {
  free(): void;
  constructor(coinId: Uint8Array);
  coinId: Uint8Array;
}
export class AssertEphemeral {
  free(): void;
  constructor();
}
export class AssertHeightAbsolute {
  free(): void;
  constructor(height: number);
  height: number;
}
export class AssertHeightRelative {
  free(): void;
  constructor(height: number);
  height: number;
}
export class AssertMyAmount {
  free(): void;
  constructor(amount: bigint);
  amount: bigint;
}
export class AssertMyBirthHeight {
  free(): void;
  constructor(height: number);
  height: number;
}
export class AssertMyBirthSeconds {
  free(): void;
  constructor(seconds: bigint);
  seconds: bigint;
}
export class AssertMyCoinId {
  free(): void;
  constructor(coinId: Uint8Array);
  coinId: Uint8Array;
}
export class AssertMyParentId {
  free(): void;
  constructor(parentId: Uint8Array);
  parentId: Uint8Array;
}
export class AssertMyPuzzleHash {
  free(): void;
  constructor(puzzleHash: Uint8Array);
  puzzleHash: Uint8Array;
}
export class AssertPuzzleAnnouncement {
  free(): void;
  constructor(announcementId: Uint8Array);
  announcementId: Uint8Array;
}
export class AssertSecondsAbsolute {
  free(): void;
  constructor(seconds: bigint);
  seconds: bigint;
}
export class AssertSecondsRelative {
  free(): void;
  constructor(seconds: bigint);
  seconds: bigint;
}
export class BlockRecord {
  free(): void;
  constructor(headerHash: Uint8Array, prevHash: Uint8Array, height: number, weight: bigint, totalIters: bigint, signagePointIndex: number, challengeVdfOutput: Uint8Array, infusedChallengeVdfOutput: Uint8Array | null | undefined, rewardInfusionNewChallenge: Uint8Array, challengeBlockInfoHash: Uint8Array, subSlotIters: bigint, poolPuzzleHash: Uint8Array, farmerPuzzleHash: Uint8Array, requiredIters: bigint, deficit: number, overflow: boolean, prevTransactionBlockHeight: number, timestamp?: bigint | null, prevTransactionBlockHash?: Uint8Array | null, fees?: bigint | null, rewardClaimsIncorporated?: Coin[] | null, finishedChallengeSlotHashes?: Array<any> | null, finishedInfusedChallengeSlotHashes?: Array<any> | null, finishedRewardSlotHashes?: Array<any> | null, subEpochSummaryIncluded?: SubEpochSummary | null);
  headerHash: Uint8Array;
  prevHash: Uint8Array;
  height: number;
  weight: bigint;
  totalIters: bigint;
  signagePointIndex: number;
  challengeVdfOutput: Uint8Array;
  get infusedChallengeVdfOutput(): Uint8Array | undefined;
  set infusedChallengeVdfOutput(value: Uint8Array | null | undefined);
  rewardInfusionNewChallenge: Uint8Array;
  challengeBlockInfoHash: Uint8Array;
  subSlotIters: bigint;
  poolPuzzleHash: Uint8Array;
  farmerPuzzleHash: Uint8Array;
  requiredIters: bigint;
  deficit: number;
  overflow: boolean;
  prevTransactionBlockHeight: number;
  get timestamp(): bigint | undefined;
  set timestamp(value: bigint | null | undefined);
  get prevTransactionBlockHash(): Uint8Array | undefined;
  set prevTransactionBlockHash(value: Uint8Array | null | undefined);
  get fees(): bigint | undefined;
  set fees(value: bigint | null | undefined);
  get rewardClaimsIncorporated(): Coin[] | undefined;
  set rewardClaimsIncorporated(value: Coin[] | null | undefined);
  get finishedChallengeSlotHashes(): Array<any> | undefined;
  set finishedChallengeSlotHashes(value: Array<any> | null | undefined);
  get finishedInfusedChallengeSlotHashes(): Array<any> | undefined;
  set finishedInfusedChallengeSlotHashes(value: Array<any> | null | undefined);
  get finishedRewardSlotHashes(): Array<any> | undefined;
  set finishedRewardSlotHashes(value: Array<any> | null | undefined);
  get subEpochSummaryIncluded(): SubEpochSummary | undefined;
  set subEpochSummaryIncluded(value: SubEpochSummary | null | undefined);
}
export class BlockchainState {
  free(): void;
  constructor(averageBlockTime: bigint, blockMaxCost: bigint, difficulty: bigint, genesisChallengeInitialized: boolean, mempoolCost: bigint, mempoolFees: bigint, mempoolMaxTotalCost: bigint, mempoolMinFees: MempoolMinFees, mempoolSize: number, nodeId: Uint8Array, peak: BlockRecord, space: bigint, subSlotIters: bigint, sync: SyncState);
  averageBlockTime: bigint;
  blockMaxCost: bigint;
  difficulty: bigint;
  genesisChallengeInitialized: boolean;
  mempoolCost: bigint;
  mempoolFees: bigint;
  mempoolMaxTotalCost: bigint;
  mempoolMinFees: MempoolMinFees;
  mempoolSize: number;
  nodeId: Uint8Array;
  peak: BlockRecord;
  space: bigint;
  subSlotIters: bigint;
  sync: SyncState;
}
export class BlockchainStateResponse {
  free(): void;
  constructor(blockchainState: BlockchainState | null | undefined, error: string | null | undefined, success: boolean);
  get blockchainState(): BlockchainState | undefined;
  set blockchainState(value: BlockchainState | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class BlsPair {
  free(): void;
  static fromSeed(seed: bigint): BlsPair;
  static manyFromSeed(seed: bigint, count: number): BlsPair[];
  constructor(sk: SecretKey, pk: PublicKey);
  sk: SecretKey;
  pk: PublicKey;
}
export class BlsPairWithCoin {
  free(): void;
  constructor(sk: SecretKey, pk: PublicKey, puzzleHash: Uint8Array, coin: Coin);
  sk: SecretKey;
  pk: PublicKey;
  puzzleHash: Uint8Array;
  coin: Coin;
}
export class Cat {
  free(): void;
  constructor(coin: Coin, lineageProof: LineageProof | null | undefined, assetId: Uint8Array, p2PuzzleHash: Uint8Array);
  coin: Coin;
  get lineageProof(): LineageProof | undefined;
  set lineageProof(value: LineageProof | null | undefined);
  assetId: Uint8Array;
  p2PuzzleHash: Uint8Array;
}
export class CatSpend {
  free(): void;
  constructor(cat: Cat, spend: Spend);
  cat: Cat;
  spend: Spend;
}
export class ChallengeChainSubSlot {
  free(): void;
  constructor(challengeChainEndOfSlotVdf: VDFInfo, infusedChallengeChainSubSlotHash?: Uint8Array | null, subepochSummaryHash?: Uint8Array | null, newSubSlotIters?: bigint | null, newDifficulty?: bigint | null);
  challengeChainEndOfSlotVdf: VDFInfo;
  get infusedChallengeChainSubSlotHash(): Uint8Array | undefined;
  set infusedChallengeChainSubSlotHash(value: Uint8Array | null | undefined);
  get subepochSummaryHash(): Uint8Array | undefined;
  set subepochSummaryHash(value: Uint8Array | null | undefined);
  get newSubSlotIters(): bigint | undefined;
  set newSubSlotIters(value: bigint | null | undefined);
  get newDifficulty(): bigint | undefined;
  set newDifficulty(value: bigint | null | undefined);
}
export class Clvm {
  free(): void;
  constructor();
  addCoinSpend(coinSpend: CoinSpend): void;
  spendCoin(coin: Coin, spend: Spend): void;
  coinSpends(): CoinSpend[];
  parse(program: string): Program;
  deserialize(value: Uint8Array): Program;
  deserializeWithBackrefs(value: Uint8Array): Program;
  cache(modHash: Uint8Array, value: Uint8Array): Program;
  pair(first: Program, rest: Program): Program;
  nil(): Program;
  int(value: bigint): Program;
  string(value: string): Program;
  bool(value: boolean): Program;
  atom(value: Uint8Array): Program;
  list(value: Program[]): Program;
  delegatedSpend(conditions: Program[]): Spend;
  standardSpend(syntheticKey: PublicKey, spend: Spend): Spend;
  spendStandardCoin(coin: Coin, syntheticKey: PublicKey, spend: Spend): void;
  spendCatCoins(catSpends: CatSpend[]): void;
  mintNfts(parentCoinId: Uint8Array, nftMints: NftMint[]): MintedNfts;
  spendNft(nft: Nft, innerSpend: Spend): void;
  spendDid(did: Did, innerSpend: Spend): void;
  spendStreamedCat(streamedCat: StreamedCat, paymentTime: bigint, clawback: boolean): void;
  mintVault(parentCoinId: Uint8Array, custodyHash: Uint8Array, memos: Program): VaultMint;
  mipsSpend(coin: Coin, delegatedSpend: Spend): MipsSpend;
  nftMetadata(value: NftMetadata): Program;
  remark(rest: Program): Program;
  aggSigParent(publicKey: PublicKey, message: Uint8Array): Program;
  aggSigPuzzle(publicKey: PublicKey, message: Uint8Array): Program;
  aggSigAmount(publicKey: PublicKey, message: Uint8Array): Program;
  aggSigPuzzleAmount(publicKey: PublicKey, message: Uint8Array): Program;
  aggSigParentAmount(publicKey: PublicKey, message: Uint8Array): Program;
  aggSigParentPuzzle(publicKey: PublicKey, message: Uint8Array): Program;
  aggSigUnsafe(publicKey: PublicKey, message: Uint8Array): Program;
  aggSigMe(publicKey: PublicKey, message: Uint8Array): Program;
  createCoin(puzzleHash: Uint8Array, amount: bigint, memos?: Program | null): Program;
  reserveFee(amount: bigint): Program;
  createCoinAnnouncement(message: Uint8Array): Program;
  createPuzzleAnnouncement(message: Uint8Array): Program;
  assertCoinAnnouncement(announcementId: Uint8Array): Program;
  assertPuzzleAnnouncement(announcementId: Uint8Array): Program;
  assertConcurrentSpend(coinId: Uint8Array): Program;
  assertConcurrentPuzzle(puzzleHash: Uint8Array): Program;
  assertSecondsRelative(seconds: bigint): Program;
  assertSecondsAbsolute(seconds: bigint): Program;
  assertHeightRelative(height: number): Program;
  assertHeightAbsolute(height: number): Program;
  assertBeforeSecondsRelative(seconds: bigint): Program;
  assertBeforeSecondsAbsolute(seconds: bigint): Program;
  assertBeforeHeightRelative(height: number): Program;
  assertBeforeHeightAbsolute(height: number): Program;
  assertMyCoinId(coinId: Uint8Array): Program;
  assertMyParentId(parentId: Uint8Array): Program;
  assertMyPuzzleHash(puzzleHash: Uint8Array): Program;
  assertMyAmount(amount: bigint): Program;
  assertMyBirthSeconds(seconds: bigint): Program;
  assertMyBirthHeight(height: number): Program;
  assertEphemeral(): Program;
  sendMessage(mode: number, message: Uint8Array, data: Program[]): Program;
  receiveMessage(mode: number, message: Uint8Array, data: Program[]): Program;
  softfork(cost: bigint, rest: Program): Program;
  boundCheckedNumber(value: number): Program;
}
export class Coin {
  free(): void;
  coinId(): Uint8Array;
  constructor(parentCoinInfo: Uint8Array, puzzleHash: Uint8Array, amount: bigint);
  parentCoinInfo: Uint8Array;
  puzzleHash: Uint8Array;
  amount: bigint;
}
export class CoinRecord {
  free(): void;
  constructor(coin: Coin, coinbase: boolean, confirmedBlockIndex: number, spent: boolean, spentBlockIndex: number, timestamp: bigint);
  coin: Coin;
  coinbase: boolean;
  confirmedBlockIndex: number;
  spent: boolean;
  spentBlockIndex: number;
  timestamp: bigint;
}
export class CoinSpend {
  free(): void;
  constructor(coin: Coin, puzzleReveal: Uint8Array, solution: Uint8Array);
  coin: Coin;
  puzzleReveal: Uint8Array;
  solution: Uint8Array;
}
export class CoinsetClient {
  free(): void;
  constructor(baseUrl: string);
  static testnet11(): CoinsetClient;
  static mainnet(): CoinsetClient;
  getBlockchainState(): Promise<BlockchainStateResponse>;
  getAdditionsAndRemovals(headerHash: Uint8Array): Promise<AdditionsAndRemovalsResponse>;
  getBlock(headerHash: Uint8Array): Promise<GetBlockResponse>;
  getBlockRecord(headerHash: Uint8Array): Promise<GetBlockRecordResponse>;
  getBlockRecordByHeight(height: number): Promise<GetBlockRecordResponse>;
  getBlockRecords(startHeight: number, endHeight: number): Promise<GetBlockRecordsResponse>;
  getBlocks(start: number, end: number, excludeHeaderHash: boolean, excludeReorged: boolean): Promise<GetBlocksResponse>;
  getBlockSpends(headerHash: Uint8Array): Promise<GetBlockSpendsResponse>;
  getCoinRecordByName(name: Uint8Array): Promise<GetCoinRecordResponse>;
  getCoinRecordsByHint(hint: Uint8Array, startHeight?: number | null, endHeight?: number | null, includeSpentCoins?: boolean | null): Promise<GetCoinRecordsResponse>;
  getCoinRecordsByNames(names: Array<any>, startHeight?: number | null, endHeight?: number | null, includeSpentCoins?: boolean | null): Promise<GetCoinRecordsResponse>;
  getCoinRecordsByParentIds(parentIds: Array<any>, startHeight?: number | null, endHeight?: number | null, includeSpentCoins?: boolean | null): Promise<GetCoinRecordsResponse>;
  getCoinRecordsByPuzzleHash(puzzleHash: Uint8Array, startHeight?: number | null, endHeight?: number | null, includeSpentCoins?: boolean | null): Promise<GetCoinRecordsResponse>;
  getCoinRecordsByPuzzleHashes(puzzleHashes: Array<any>, startHeight?: number | null, endHeight?: number | null, includeSpentCoins?: boolean | null): Promise<GetCoinRecordsResponse>;
  getPuzzleAndSolution(coinId: Uint8Array, height?: number | null): Promise<GetPuzzleAndSolutionResponse>;
  pushTx(spendBundle: SpendBundle): Promise<PushTxResponse>;
  getNetworkInfo(): Promise<GetNetworkInfoResponse>;
  getMempoolItemByTxId(txId: Uint8Array): Promise<GetMempoolItemResponse>;
  getMempoolItemsByCoinName(coinName: Uint8Array): Promise<GetMempoolItemsResponse>;
}
export class Constants {
  private constructor();
  free(): void;
  static acsTransferProgram(): Uint8Array;
  static acsTransferProgramHash(): Uint8Array;
  static augmentedCondition(): Uint8Array;
  static augmentedConditionHash(): Uint8Array;
  static blockProgramZero(): Uint8Array;
  static blockProgramZeroHash(): Uint8Array;
  static catPuzzle(): Uint8Array;
  static catPuzzleHash(): Uint8Array;
  static chialispDeserialisation(): Uint8Array;
  static chialispDeserialisationHash(): Uint8Array;
  static conditionsWFeeAnnounce(): Uint8Array;
  static conditionsWFeeAnnounceHash(): Uint8Array;
  static covenantLayer(): Uint8Array;
  static covenantLayerHash(): Uint8Array;
  static createNftLauncherFromDid(): Uint8Array;
  static createNftLauncherFromDidHash(): Uint8Array;
  static credentialRestriction(): Uint8Array;
  static credentialRestrictionHash(): Uint8Array;
  static daoCatEve(): Uint8Array;
  static daoCatEveHash(): Uint8Array;
  static daoCatLauncher(): Uint8Array;
  static daoCatLauncherHash(): Uint8Array;
  static daoFinishedState(): Uint8Array;
  static daoFinishedStateHash(): Uint8Array;
  static daoLockup(): Uint8Array;
  static daoLockupHash(): Uint8Array;
  static daoProposal(): Uint8Array;
  static daoProposalHash(): Uint8Array;
  static daoProposalTimer(): Uint8Array;
  static daoProposalTimerHash(): Uint8Array;
  static daoProposalValidator(): Uint8Array;
  static daoProposalValidatorHash(): Uint8Array;
  static daoSpendP2Singleton(): Uint8Array;
  static daoSpendP2SingletonHash(): Uint8Array;
  static daoTreasury(): Uint8Array;
  static daoTreasuryHash(): Uint8Array;
  static daoUpdateProposal(): Uint8Array;
  static daoUpdateProposalHash(): Uint8Array;
  static decompressCoinSpendEntry(): Uint8Array;
  static decompressCoinSpendEntryHash(): Uint8Array;
  static decompressCoinSpendEntryWithPrefix(): Uint8Array;
  static decompressCoinSpendEntryWithPrefixHash(): Uint8Array;
  static decompressPuzzle(): Uint8Array;
  static decompressPuzzleHash(): Uint8Array;
  static delegatedTail(): Uint8Array;
  static delegatedTailHash(): Uint8Array;
  static didInnerpuzzle(): Uint8Array;
  static didInnerpuzzleHash(): Uint8Array;
  static emlCovenantMorpher(): Uint8Array;
  static emlCovenantMorpherHash(): Uint8Array;
  static emlTransferProgramCovenantAdapter(): Uint8Array;
  static emlTransferProgramCovenantAdapterHash(): Uint8Array;
  static emlUpdateMetadataWithDid(): Uint8Array;
  static emlUpdateMetadataWithDidHash(): Uint8Array;
  static everythingWithSignature(): Uint8Array;
  static everythingWithSignatureHash(): Uint8Array;
  static exigentMetadataLayer(): Uint8Array;
  static exigentMetadataLayerHash(): Uint8Array;
  static flagProofsChecker(): Uint8Array;
  static flagProofsCheckerHash(): Uint8Array;
  static genesisByCoinId(): Uint8Array;
  static genesisByCoinIdHash(): Uint8Array;
  static genesisByCoinIdOrSingleton(): Uint8Array;
  static genesisByCoinIdOrSingletonHash(): Uint8Array;
  static genesisByPuzzleHash(): Uint8Array;
  static genesisByPuzzleHashHash(): Uint8Array;
  static graftrootDlOffers(): Uint8Array;
  static graftrootDlOffersHash(): Uint8Array;
  static nftIntermediateLauncher(): Uint8Array;
  static nftIntermediateLauncherHash(): Uint8Array;
  static nftMetadataUpdaterDefault(): Uint8Array;
  static nftMetadataUpdaterDefaultHash(): Uint8Array;
  static nftMetadataUpdaterUpdateable(): Uint8Array;
  static nftMetadataUpdaterUpdateableHash(): Uint8Array;
  static nftOwnershipLayer(): Uint8Array;
  static nftOwnershipLayerHash(): Uint8Array;
  static nftOwnershipTransferProgramOneWayClaimWithRoyalties(): Uint8Array;
  static nftOwnershipTransferProgramOneWayClaimWithRoyaltiesHash(): Uint8Array;
  static nftStateLayer(): Uint8Array;
  static nftStateLayerHash(): Uint8Array;
  static notification(): Uint8Array;
  static notificationHash(): Uint8Array;
  static p21OfN(): Uint8Array;
  static p21OfNHash(): Uint8Array;
  static p2AnnouncedDelegatedPuzzle(): Uint8Array;
  static p2AnnouncedDelegatedPuzzleHash(): Uint8Array;
  static p2Conditions(): Uint8Array;
  static p2ConditionsHash(): Uint8Array;
  static p2DelegatedConditions(): Uint8Array;
  static p2DelegatedConditionsHash(): Uint8Array;
  static p2DelegatedPuzzle(): Uint8Array;
  static p2DelegatedPuzzleHash(): Uint8Array;
  static p2DelegatedPuzzleOrHiddenPuzzle(): Uint8Array;
  static p2DelegatedPuzzleOrHiddenPuzzleHash(): Uint8Array;
  static p2MOfNDelegateDirect(): Uint8Array;
  static p2MOfNDelegateDirectHash(): Uint8Array;
  static p2Parent(): Uint8Array;
  static p2ParentHash(): Uint8Array;
  static p2PuzzleHash(): Uint8Array;
  static p2PuzzleHashHash(): Uint8Array;
  static p2Singleton(): Uint8Array;
  static p2SingletonHash(): Uint8Array;
  static p2SingletonAggregator(): Uint8Array;
  static p2SingletonAggregatorHash(): Uint8Array;
  static p2SingletonOrDelayedPuzzleHash(): Uint8Array;
  static p2SingletonOrDelayedPuzzleHashHash(): Uint8Array;
  static p2SingletonViaDelegatedPuzzle(): Uint8Array;
  static p2SingletonViaDelegatedPuzzleHash(): Uint8Array;
  static poolMemberInnerpuzzle(): Uint8Array;
  static poolMemberInnerpuzzleHash(): Uint8Array;
  static poolWaitingroomInnerpuzzle(): Uint8Array;
  static poolWaitingroomInnerpuzzleHash(): Uint8Array;
  static revocationLayer(): Uint8Array;
  static revocationLayerHash(): Uint8Array;
  static romBootstrapGenerator(): Uint8Array;
  static romBootstrapGeneratorHash(): Uint8Array;
  static settlementPayment(): Uint8Array;
  static settlementPaymentHash(): Uint8Array;
  static singletonLauncher(): Uint8Array;
  static singletonLauncherHash(): Uint8Array;
  static singletonTopLayer(): Uint8Array;
  static singletonTopLayerHash(): Uint8Array;
  static singletonTopLayerV11(): Uint8Array;
  static singletonTopLayerV11Hash(): Uint8Array;
  static standardVcRevocationPuzzle(): Uint8Array;
  static standardVcRevocationPuzzleHash(): Uint8Array;
  static stdParentMorpher(): Uint8Array;
  static stdParentMorpherHash(): Uint8Array;
  static optionContract(): Uint8Array;
  static optionContractHash(): Uint8Array;
  static p2Curried(): Uint8Array;
  static p2CurriedHash(): Uint8Array;
}
export class CreateCoin {
  free(): void;
  constructor(puzzleHash: Uint8Array, amount: bigint, memos?: Program | null);
  puzzleHash: Uint8Array;
  amount: bigint;
  get memos(): Program | undefined;
  set memos(value: Program | null | undefined);
}
export class CreateCoinAnnouncement {
  free(): void;
  constructor(message: Uint8Array);
  message: Uint8Array;
}
export class CreatePuzzleAnnouncement {
  free(): void;
  constructor(message: Uint8Array);
  message: Uint8Array;
}
export class CurriedProgram {
  free(): void;
  constructor(program: Program, args: Program[]);
  program: Program;
  args: Program[];
}
export class Did {
  free(): void;
  constructor(coin: Coin, lineageProof: LineageProof, info: DidInfo);
  coin: Coin;
  lineageProof: LineageProof;
  info: DidInfo;
}
export class DidInfo {
  free(): void;
  constructor(launcherId: Uint8Array, recoveryListHash: Uint8Array | null | undefined, numVerificationsRequired: bigint, metadata: Program, p2PuzzleHash: Uint8Array);
  launcherId: Uint8Array;
  get recoveryListHash(): Uint8Array | undefined;
  set recoveryListHash(value: Uint8Array | null | undefined);
  numVerificationsRequired: bigint;
  metadata: Program;
  p2PuzzleHash: Uint8Array;
}
export class DidOwner {
  free(): void;
  constructor(didId: Uint8Array, innerPuzzleHash: Uint8Array);
  didId: Uint8Array;
  innerPuzzleHash: Uint8Array;
}
export class EndOfSubSlotBundle {
  free(): void;
  constructor(challengeChain: ChallengeChainSubSlot, infusedChallengeChain: InfusedChallengeChainSubSlot | null | undefined, rewardChain: RewardChainSubSlot, proofs: SubSlotProofs);
  challengeChain: ChallengeChainSubSlot;
  get infusedChallengeChain(): InfusedChallengeChainSubSlot | undefined;
  set infusedChallengeChain(value: InfusedChallengeChainSubSlot | null | undefined);
  rewardChain: RewardChainSubSlot;
  proofs: SubSlotProofs;
}
export class Foliage {
  free(): void;
  constructor(prevBlockHash: Uint8Array, rewardBlockHash: Uint8Array, foliageBlockData: FoliageBlockData, foliageBlockDataSignature: Signature, foliageTransactionBlockHash?: Uint8Array | null, foliageTransactionBlockSignature?: Signature | null);
  prevBlockHash: Uint8Array;
  rewardBlockHash: Uint8Array;
  foliageBlockData: FoliageBlockData;
  foliageBlockDataSignature: Signature;
  get foliageTransactionBlockHash(): Uint8Array | undefined;
  set foliageTransactionBlockHash(value: Uint8Array | null | undefined);
  get foliageTransactionBlockSignature(): Signature | undefined;
  set foliageTransactionBlockSignature(value: Signature | null | undefined);
}
export class FoliageBlockData {
  free(): void;
  constructor(unfinishedRewardBlockHash: Uint8Array, poolTarget: PoolTarget, poolSignature: Signature | null | undefined, farmerRewardPuzzleHash: Uint8Array, extensionData: Uint8Array);
  unfinishedRewardBlockHash: Uint8Array;
  poolTarget: PoolTarget;
  get poolSignature(): Signature | undefined;
  set poolSignature(value: Signature | null | undefined);
  farmerRewardPuzzleHash: Uint8Array;
  extensionData: Uint8Array;
}
export class FoliageTransactionBlock {
  free(): void;
  constructor(prevTransactionBlockHash: Uint8Array, timestamp: bigint, filterHash: Uint8Array, additionsRoot: Uint8Array, removalsRoot: Uint8Array, transactionsInfoHash: Uint8Array);
  prevTransactionBlockHash: Uint8Array;
  timestamp: bigint;
  filterHash: Uint8Array;
  additionsRoot: Uint8Array;
  removalsRoot: Uint8Array;
  transactionsInfoHash: Uint8Array;
}
export class FullBlock {
  free(): void;
  constructor(finishedSubSlots: EndOfSubSlotBundle[], rewardChainBlock: RewardChainBlock, challengeChainSpProof: VDFProof | null | undefined, challengeChainIpProof: VDFProof, rewardChainSpProof: VDFProof | null | undefined, rewardChainIpProof: VDFProof, infusedChallengeChainIpProof: VDFProof | null | undefined, foliage: Foliage, foliageTransactionBlock: FoliageTransactionBlock | null | undefined, transactionsInfo: TransactionsInfo | null | undefined, transactionsGenerator: Uint8Array | null | undefined, transactionsGeneratorRefList: Uint32Array);
  finishedSubSlots: EndOfSubSlotBundle[];
  rewardChainBlock: RewardChainBlock;
  get challengeChainSpProof(): VDFProof | undefined;
  set challengeChainSpProof(value: VDFProof | null | undefined);
  challengeChainIpProof: VDFProof;
  get rewardChainSpProof(): VDFProof | undefined;
  set rewardChainSpProof(value: VDFProof | null | undefined);
  rewardChainIpProof: VDFProof;
  get infusedChallengeChainIpProof(): VDFProof | undefined;
  set infusedChallengeChainIpProof(value: VDFProof | null | undefined);
  foliage: Foliage;
  get foliageTransactionBlock(): FoliageTransactionBlock | undefined;
  set foliageTransactionBlock(value: FoliageTransactionBlock | null | undefined);
  get transactionsInfo(): TransactionsInfo | undefined;
  set transactionsInfo(value: TransactionsInfo | null | undefined);
  get transactionsGenerator(): Uint8Array | undefined;
  set transactionsGenerator(value: Uint8Array | null | undefined);
  transactionsGeneratorRefList: Uint32Array;
}
export class GetBlockRecordResponse {
  free(): void;
  constructor(blockRecord: BlockRecord | null | undefined, error: string | null | undefined, success: boolean);
  get blockRecord(): BlockRecord | undefined;
  set blockRecord(value: BlockRecord | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetBlockRecordsResponse {
  free(): void;
  constructor(blockRecords: BlockRecord[] | null | undefined, error: string | null | undefined, success: boolean);
  get blockRecords(): BlockRecord[] | undefined;
  set blockRecords(value: BlockRecord[] | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetBlockResponse {
  free(): void;
  constructor(block: FullBlock | null | undefined, error: string | null | undefined, success: boolean);
  get block(): FullBlock | undefined;
  set block(value: FullBlock | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetBlockSpendsResponse {
  free(): void;
  constructor(blockSpends: CoinSpend[] | null | undefined, error: string | null | undefined, success: boolean);
  get blockSpends(): CoinSpend[] | undefined;
  set blockSpends(value: CoinSpend[] | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetBlocksResponse {
  free(): void;
  constructor(blocks: FullBlock[] | null | undefined, error: string | null | undefined, success: boolean);
  get blocks(): FullBlock[] | undefined;
  set blocks(value: FullBlock[] | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetCoinRecordResponse {
  free(): void;
  constructor(coinRecord: CoinRecord | null | undefined, error: string | null | undefined, success: boolean);
  get coinRecord(): CoinRecord | undefined;
  set coinRecord(value: CoinRecord | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetCoinRecordsResponse {
  free(): void;
  constructor(coinRecords: CoinRecord[] | null | undefined, error: string | null | undefined, success: boolean);
  get coinRecords(): CoinRecord[] | undefined;
  set coinRecords(value: CoinRecord[] | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetMempoolItemResponse {
  free(): void;
  constructor(mempoolItem: MempoolItem | null | undefined, error: string | null | undefined, success: boolean);
  get mempoolItem(): MempoolItem | undefined;
  set mempoolItem(value: MempoolItem | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetMempoolItemsResponse {
  free(): void;
  constructor(mempoolItems: MempoolItem[] | null | undefined, error: string | null | undefined, success: boolean);
  get mempoolItems(): MempoolItem[] | undefined;
  set mempoolItems(value: MempoolItem[] | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetNetworkInfoResponse {
  free(): void;
  constructor(networkName: string | null | undefined, networkPrefix: string | null | undefined, genesisChallenge: Uint8Array | null | undefined, error: string | null | undefined, success: boolean);
  get networkName(): string | undefined;
  set networkName(value: string | null | undefined);
  get networkPrefix(): string | undefined;
  set networkPrefix(value: string | null | undefined);
  get genesisChallenge(): Uint8Array | undefined;
  set genesisChallenge(value: Uint8Array | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class GetPuzzleAndSolutionResponse {
  free(): void;
  constructor(coinSolution: CoinSpend | null | undefined, error: string | null | undefined, success: boolean);
  get coinSolution(): CoinSpend | undefined;
  set coinSolution(value: CoinSpend | null | undefined);
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class InfusedChallengeChainSubSlot {
  free(): void;
  constructor(infusedChallengeChainEndOfSlotVdf: VDFInfo);
  infusedChallengeChainEndOfSlotVdf: VDFInfo;
}
export class K1Pair {
  free(): void;
  static fromSeed(seed: bigint): K1Pair;
  static manyFromSeed(seed: bigint, count: number): K1Pair[];
  constructor(sk: K1SecretKey, pk: K1PublicKey);
  sk: K1SecretKey;
  pk: K1PublicKey;
}
export class K1PublicKey {
  private constructor();
  free(): void;
  static fromBytes(bytes: Uint8Array): K1PublicKey;
  toBytes(): Uint8Array;
  fingerprint(): number;
  verifyPrehashed(prehashed: Uint8Array, signature: K1Signature): boolean;
}
export class K1SecretKey {
  private constructor();
  free(): void;
  static fromBytes(bytes: Uint8Array): K1SecretKey;
  toBytes(): Uint8Array;
  publicKey(): K1PublicKey;
  signPrehashed(prehashed: Uint8Array): K1Signature;
}
export class K1Signature {
  private constructor();
  free(): void;
  static fromBytes(bytes: Uint8Array): K1Signature;
  toBytes(): Uint8Array;
}
export class LineageProof {
  free(): void;
  constructor(parentParentCoinInfo: Uint8Array, parentInnerPuzzleHash: Uint8Array | null | undefined, parentAmount: bigint);
  parentParentCoinInfo: Uint8Array;
  get parentInnerPuzzleHash(): Uint8Array | undefined;
  set parentInnerPuzzleHash(value: Uint8Array | null | undefined);
  parentAmount: bigint;
}
export class MemberConfig {
  free(): void;
  constructor();
  withTopLevel(topLevel: boolean): MemberConfig;
  withNonce(nonce: number): MemberConfig;
  withRestrictions(restrictions: Restriction[]): MemberConfig;
  topLevel: boolean;
  nonce: number;
  restrictions: Restriction[];
}
export class MempoolItem {
  free(): void;
  constructor(spendBundle: SpendBundle, fee: bigint);
  spendBundle: SpendBundle;
  fee: bigint;
}
export class MempoolMinFees {
  free(): void;
  constructor(cost5000000: bigint);
  cost5000000: bigint;
}
export class MintedNfts {
  free(): void;
  constructor(nfts: Nft[], parentConditions: Program[]);
  nfts: Nft[];
  parentConditions: Program[];
}
export class MipsSpend {
  private constructor();
  free(): void;
  spend(custodyHash: Uint8Array): Spend;
  spendVault(vault: Vault): void;
  mOfN(config: MemberConfig, required: number, items: Array<any>): void;
  k1Member(config: MemberConfig, publicKey: K1PublicKey, signature: K1Signature, fastForward: boolean): void;
  r1Member(config: MemberConfig, publicKey: R1PublicKey, signature: R1Signature, fastForward: boolean): void;
  blsMember(config: MemberConfig, publicKey: PublicKey): void;
  passkeyMember(config: MemberConfig, publicKey: R1PublicKey, signature: R1Signature, authenticatorData: Uint8Array, clientDataJson: Uint8Array, challengeIndex: number, fastForward: boolean): void;
  singletonMember(config: MemberConfig, launcherId: Uint8Array, singletonInnerPuzzleHash: Uint8Array, singletonAmount: bigint): void;
  fixedPuzzleMember(config: MemberConfig, fixedPuzzleHash: Uint8Array): void;
  customMember(config: MemberConfig, spend: Spend): void;
  timelock(timelock: bigint): void;
  force1Of2RestrictedVariable(leftSideSubtreeHash: Uint8Array, nonce: number, memberValidatorListHash: Uint8Array, delegatedPuzzleValidatorListHash: Uint8Array, newRightSideMemberHash: Uint8Array): void;
  preventConditionOpcode(conditionOpcode: number): void;
  preventMultipleCreateCoins(): void;
  preventVaultSideEffects(): void;
}
export class Mnemonic {
  free(): void;
  constructor(mnemonic: string);
  static fromEntropy(entropy: Uint8Array): Mnemonic;
  static generate(use24: boolean): Mnemonic;
  static verify(mnemonic: string): boolean;
  toString(): string;
  toEntropy(): Uint8Array;
  toSeed(password: string): Uint8Array;
}
export class Nft {
  free(): void;
  constructor(coin: Coin, lineageProof: LineageProof, info: NftInfo);
  coin: Coin;
  lineageProof: LineageProof;
  info: NftInfo;
}
export class NftInfo {
  free(): void;
  constructor(launcherId: Uint8Array, metadata: Program, metadataUpdaterPuzzleHash: Uint8Array, currentOwner: Uint8Array | null | undefined, royaltyPuzzleHash: Uint8Array, royaltyTenThousandths: number, p2PuzzleHash: Uint8Array);
  launcherId: Uint8Array;
  metadata: Program;
  metadataUpdaterPuzzleHash: Uint8Array;
  get currentOwner(): Uint8Array | undefined;
  set currentOwner(value: Uint8Array | null | undefined);
  royaltyPuzzleHash: Uint8Array;
  royaltyTenThousandths: number;
  p2PuzzleHash: Uint8Array;
}
export class NftMetadata {
  free(): void;
  constructor(editionNumber: bigint, editionTotal: bigint, dataUris: string[], dataHash: Uint8Array | null | undefined, metadataUris: string[], metadataHash: Uint8Array | null | undefined, licenseUris: string[], licenseHash?: Uint8Array | null);
  editionNumber: bigint;
  editionTotal: bigint;
  dataUris: string[];
  get dataHash(): Uint8Array | undefined;
  set dataHash(value: Uint8Array | null | undefined);
  metadataUris: string[];
  get metadataHash(): Uint8Array | undefined;
  set metadataHash(value: Uint8Array | null | undefined);
  licenseUris: string[];
  get licenseHash(): Uint8Array | undefined;
  set licenseHash(value: Uint8Array | null | undefined);
}
export class NftMint {
  free(): void;
  constructor(metadata: Program, metadataUpdaterPuzzleHash: Uint8Array, p2PuzzleHash: Uint8Array, royaltyPuzzleHash: Uint8Array, royaltyTenThousandths: number, owner?: DidOwner | null);
  metadata: Program;
  metadataUpdaterPuzzleHash: Uint8Array;
  p2PuzzleHash: Uint8Array;
  royaltyPuzzleHash: Uint8Array;
  royaltyTenThousandths: number;
  get owner(): DidOwner | undefined;
  set owner(value: DidOwner | null | undefined);
}
export class Output {
  free(): void;
  constructor(value: Program, cost: bigint);
  value: Program;
  cost: bigint;
}
export class Pair {
  free(): void;
  constructor(first: Program, rest: Program);
  first: Program;
  rest: Program;
}
export class ParsedCat {
  free(): void;
  constructor(assetId: Uint8Array, p2Puzzle: Puzzle);
  assetId: Uint8Array;
  p2Puzzle: Puzzle;
}
export class ParsedDid {
  free(): void;
  constructor(info: DidInfo, p2Puzzle: Puzzle);
  info: DidInfo;
  p2Puzzle: Puzzle;
}
export class ParsedNft {
  free(): void;
  constructor(info: NftInfo, p2Puzzle: Puzzle);
  info: NftInfo;
  p2Puzzle: Puzzle;
}
export class PoolTarget {
  free(): void;
  constructor(puzzleHash: Uint8Array, maxHeight: number);
  puzzleHash: Uint8Array;
  maxHeight: number;
}
export class Program {
  private constructor();
  free(): void;
  compile(): Output;
  unparse(): string;
  serialize(): Uint8Array;
  serializeWithBackrefs(): Uint8Array;
  run(solution: Program, maxCost: bigint, mempoolMode: boolean): Output;
  curry(args: Program[]): Program;
  uncurry(): CurriedProgram | undefined;
  treeHash(): Uint8Array;
  isAtom(): boolean;
  isPair(): boolean;
  isNull(): boolean;
  length(): number;
  first(): Program;
  rest(): Program;
  toInt(): bigint | undefined;
  toString(): string | undefined;
  toBool(): boolean | undefined;
  toAtom(): Uint8Array | undefined;
  toList(): Program[] | undefined;
  toPair(): Pair | undefined;
  puzzle(): Puzzle;
  parseNftMetadata(): NftMetadata | undefined;
  parseRemark(): Remark | undefined;
  parseAggSigParent(): AggSigParent | undefined;
  parseAggSigPuzzle(): AggSigPuzzle | undefined;
  parseAggSigAmount(): AggSigAmount | undefined;
  parseAggSigPuzzleAmount(): AggSigPuzzleAmount | undefined;
  parseAggSigParentAmount(): AggSigParentAmount | undefined;
  parseAggSigParentPuzzle(): AggSigParentPuzzle | undefined;
  parseAggSigUnsafe(): AggSigUnsafe | undefined;
  parseAggSigMe(): AggSigMe | undefined;
  parseCreateCoin(): CreateCoin | undefined;
  parseReserveFee(): ReserveFee | undefined;
  parseCreateCoinAnnouncement(): CreateCoinAnnouncement | undefined;
  parseCreatePuzzleAnnouncement(): CreatePuzzleAnnouncement | undefined;
  parseAssertCoinAnnouncement(): AssertCoinAnnouncement | undefined;
  parseAssertPuzzleAnnouncement(): AssertPuzzleAnnouncement | undefined;
  parseAssertConcurrentSpend(): AssertConcurrentSpend | undefined;
  parseAssertConcurrentPuzzle(): AssertConcurrentPuzzle | undefined;
  parseAssertSecondsRelative(): AssertSecondsRelative | undefined;
  parseAssertSecondsAbsolute(): AssertSecondsAbsolute | undefined;
  parseAssertHeightRelative(): AssertHeightRelative | undefined;
  parseAssertHeightAbsolute(): AssertHeightAbsolute | undefined;
  parseAssertBeforeSecondsRelative(): AssertBeforeSecondsRelative | undefined;
  parseAssertBeforeSecondsAbsolute(): AssertBeforeSecondsAbsolute | undefined;
  parseAssertBeforeHeightRelative(): AssertBeforeHeightRelative | undefined;
  parseAssertBeforeHeightAbsolute(): AssertBeforeHeightAbsolute | undefined;
  parseAssertMyCoinId(): AssertMyCoinId | undefined;
  parseAssertMyParentId(): AssertMyParentId | undefined;
  parseAssertMyPuzzleHash(): AssertMyPuzzleHash | undefined;
  parseAssertMyAmount(): AssertMyAmount | undefined;
  parseAssertMyBirthSeconds(): AssertMyBirthSeconds | undefined;
  parseAssertMyBirthHeight(): AssertMyBirthHeight | undefined;
  parseAssertEphemeral(): AssertEphemeral | undefined;
  parseSendMessage(): SendMessage | undefined;
  parseReceiveMessage(): ReceiveMessage | undefined;
  parseSoftfork(): Softfork | undefined;
  toBoundCheckedNumber(): number | undefined;
}
export class ProofOfSpace {
  free(): void;
  constructor(challenge: Uint8Array, poolPublicKey: PublicKey | null | undefined, poolContractPuzzleHash: Uint8Array | null | undefined, plotPublicKey: PublicKey, size: number, proof: Uint8Array);
  challenge: Uint8Array;
  get poolPublicKey(): PublicKey | undefined;
  set poolPublicKey(value: PublicKey | null | undefined);
  get poolContractPuzzleHash(): Uint8Array | undefined;
  set poolContractPuzzleHash(value: Uint8Array | null | undefined);
  plotPublicKey: PublicKey;
  size: number;
  proof: Uint8Array;
}
export class PublicKey {
  private constructor();
  free(): void;
  static infinity(): PublicKey;
  static aggregate(publicKeys: PublicKey[]): PublicKey;
  static fromBytes(bytes: Uint8Array): PublicKey;
  toBytes(): Uint8Array;
  fingerprint(): number;
  isInfinity(): boolean;
  isValid(): boolean;
  deriveUnhardened(index: number): PublicKey;
  deriveUnhardenedPath(path: Uint32Array): PublicKey;
  deriveSynthetic(): PublicKey;
  deriveSyntheticHidden(hiddenPuzzleHash: Uint8Array): PublicKey;
}
export class PushTxResponse {
  free(): void;
  constructor(status: string, error: string | null | undefined, success: boolean);
  status: string;
  get error(): string | undefined;
  set error(value: string | null | undefined);
  success: boolean;
}
export class Puzzle {
  free(): void;
  parseCat(): ParsedCat | undefined;
  parseChildCats(parentCoin: Coin, parentSolution: Program): Cat[] | undefined;
  parseNft(): ParsedNft | undefined;
  parseChildNft(parentCoin: Coin, parentSolution: Program): Nft | undefined;
  parseDid(): ParsedDid | undefined;
  parseChildDid(parentCoin: Coin, parentSolution: Program, coin: Coin): Did | undefined;
  parseInnerStreamingPuzzle(): StreamingPuzzleInfo | undefined;
  parseChildStreamedCat(parentCoin: Coin, parentSolution: Program): StreamedCatParsingResult;
  constructor(puzzleHash: Uint8Array, program: Program, modHash: Uint8Array, args?: Program | null);
  puzzleHash: Uint8Array;
  program: Program;
  modHash: Uint8Array;
  get args(): Program | undefined;
  set args(value: Program | null | undefined);
}
export class R1Pair {
  free(): void;
  static fromSeed(seed: bigint): R1Pair;
  static manyFromSeed(seed: bigint, count: number): R1Pair[];
  constructor(sk: R1SecretKey, pk: R1PublicKey);
  sk: R1SecretKey;
  pk: R1PublicKey;
}
export class R1PublicKey {
  private constructor();
  free(): void;
  static fromBytes(bytes: Uint8Array): R1PublicKey;
  toBytes(): Uint8Array;
  fingerprint(): number;
  verifyPrehashed(prehashed: Uint8Array, signature: R1Signature): boolean;
}
export class R1SecretKey {
  private constructor();
  free(): void;
  static fromBytes(bytes: Uint8Array): R1SecretKey;
  toBytes(): Uint8Array;
  publicKey(): R1PublicKey;
  signPrehashed(prehashed: Uint8Array): R1Signature;
}
export class R1Signature {
  private constructor();
  free(): void;
  static fromBytes(bytes: Uint8Array): R1Signature;
  toBytes(): Uint8Array;
}
export class ReceiveMessage {
  free(): void;
  constructor(mode: number, message: Uint8Array, data: Program[]);
  mode: number;
  message: Uint8Array;
  data: Program[];
}
export class Remark {
  free(): void;
  constructor(rest: Program);
  rest: Program;
}
export class ReserveFee {
  free(): void;
  constructor(amount: bigint);
  amount: bigint;
}
export class Restriction {
  free(): void;
  constructor(kind: RestrictionKind, puzzleHash: Uint8Array);
  kind: RestrictionKind;
  puzzleHash: Uint8Array;
}
export class RewardChainBlock {
  free(): void;
  constructor(weight: bigint, height: number, totalIters: bigint, signagePointIndex: number, posSsCcChallengeHash: Uint8Array, proofOfSpace: ProofOfSpace, challengeChainSpVdf: VDFInfo | null | undefined, challengeChainSpSignature: Signature, challengeChainIpVdf: VDFInfo, rewardChainSpVdf: VDFInfo | null | undefined, rewardChainSpSignature: Signature, rewardChainIpVdf: VDFInfo, infusedChallengeChainIpVdf: VDFInfo | null | undefined, isTransactionBlock: boolean);
  weight: bigint;
  height: number;
  totalIters: bigint;
  signagePointIndex: number;
  posSsCcChallengeHash: Uint8Array;
  proofOfSpace: ProofOfSpace;
  get challengeChainSpVdf(): VDFInfo | undefined;
  set challengeChainSpVdf(value: VDFInfo | null | undefined);
  challengeChainSpSignature: Signature;
  challengeChainIpVdf: VDFInfo;
  get rewardChainSpVdf(): VDFInfo | undefined;
  set rewardChainSpVdf(value: VDFInfo | null | undefined);
  rewardChainSpSignature: Signature;
  rewardChainIpVdf: VDFInfo;
  get infusedChallengeChainIpVdf(): VDFInfo | undefined;
  set infusedChallengeChainIpVdf(value: VDFInfo | null | undefined);
  isTransactionBlock: boolean;
}
export class RewardChainSubSlot {
  free(): void;
  constructor(endOfSlotVdf: VDFInfo, challengeChainSubSlotHash: Uint8Array, infusedChallengeChainSubSlotHash: Uint8Array | null | undefined, deficit: number);
  endOfSlotVdf: VDFInfo;
  challengeChainSubSlotHash: Uint8Array;
  get infusedChallengeChainSubSlotHash(): Uint8Array | undefined;
  set infusedChallengeChainSubSlotHash(value: Uint8Array | null | undefined);
  deficit: number;
}
export class SecretKey {
  private constructor();
  free(): void;
  static fromSeed(seed: Uint8Array): SecretKey;
  static fromBytes(bytes: Uint8Array): SecretKey;
  toBytes(): Uint8Array;
  publicKey(): PublicKey;
  sign(message: Uint8Array): Signature;
  deriveUnhardened(index: number): SecretKey;
  deriveHardened(index: number): SecretKey;
  deriveUnhardenedPath(path: Uint32Array): SecretKey;
  deriveHardenedPath(path: Uint32Array): SecretKey;
  deriveSynthetic(): SecretKey;
  deriveSyntheticHidden(hiddenPuzzleHash: Uint8Array): SecretKey;
}
export class SendMessage {
  free(): void;
  constructor(mode: number, message: Uint8Array, data: Program[]);
  mode: number;
  message: Uint8Array;
  data: Program[];
}
export class Signature {
  private constructor();
  free(): void;
  static infinity(): Signature;
  static aggregate(signatures: Signature[]): Signature;
  static fromBytes(bytes: Uint8Array): Signature;
  toBytes(): Uint8Array;
  isInfinity(): boolean;
  isValid(): boolean;
}
export class Simulator {
  free(): void;
  constructor();
  newCoin(puzzleHash: Uint8Array, amount: bigint): Coin;
  bls(amount: bigint): BlsPairWithCoin;
  spendCoins(coinSpends: CoinSpend[], secretKeys: SecretKey[]): void;
}
export class Softfork {
  free(): void;
  constructor(cost: bigint, rest: Program);
  cost: bigint;
  rest: Program;
}
export class Spend {
  free(): void;
  constructor(puzzle: Program, solution: Program);
  puzzle: Program;
  solution: Program;
}
export class SpendBundle {
  free(): void;
  toBytes(): Uint8Array;
  static fromBytes(bytes: Uint8Array): SpendBundle;
  hash(): Uint8Array;
  constructor(coinSpends: CoinSpend[], aggregatedSignature: Signature);
  coinSpends: CoinSpend[];
  aggregatedSignature: Signature;
}
export class StreamedCat {
  free(): void;
  constructor(coin: Coin, assetId: Uint8Array, proof: LineageProof, info: StreamingPuzzleInfo);
  coin: Coin;
  assetId: Uint8Array;
  proof: LineageProof;
  info: StreamingPuzzleInfo;
}
export class StreamedCatParsingResult {
  free(): void;
  constructor(streamedCat: StreamedCat | null | undefined, lastSpendWasClawback: boolean, lastPaymentAmountIfClawback: bigint);
  get streamedCat(): StreamedCat | undefined;
  set streamedCat(value: StreamedCat | null | undefined);
  lastSpendWasClawback: boolean;
  lastPaymentAmountIfClawback: bigint;
}
export class StreamingPuzzleInfo {
  free(): void;
  amountToBePaid(myCoinAmount: bigint, paymentTime: bigint): bigint;
  static getHint(recipient: Uint8Array): Uint8Array;
  getLaunchHints(): Array<any>;
  innerPuzzleHash(): Uint8Array;
  static fromMemos(memos: Array<any>): StreamingPuzzleInfo | undefined;
  constructor(recipient: Uint8Array, clawbackPh: Uint8Array | null | undefined, endTime: bigint, lastPaymentTime: bigint);
  recipient: Uint8Array;
  get clawbackPh(): Uint8Array | undefined;
  set clawbackPh(value: Uint8Array | null | undefined);
  endTime: bigint;
  lastPaymentTime: bigint;
}
export class SubEpochSummary {
  free(): void;
  constructor(prevSubepochSummaryHash: Uint8Array, rewardChainHash: Uint8Array, numBlocksOverflow: number, newDifficulty?: bigint | null, newSubSlotIters?: bigint | null);
  prevSubepochSummaryHash: Uint8Array;
  rewardChainHash: Uint8Array;
  numBlocksOverflow: number;
  get newDifficulty(): bigint | undefined;
  set newDifficulty(value: bigint | null | undefined);
  get newSubSlotIters(): bigint | undefined;
  set newSubSlotIters(value: bigint | null | undefined);
}
export class SubSlotProofs {
  free(): void;
  constructor(challengeChainSlotProof: VDFProof, infusedChallengeChainSlotProof: VDFProof | null | undefined, rewardChainSlotProof: VDFProof);
  challengeChainSlotProof: VDFProof;
  get infusedChallengeChainSlotProof(): VDFProof | undefined;
  set infusedChallengeChainSlotProof(value: VDFProof | null | undefined);
  rewardChainSlotProof: VDFProof;
}
export class SyncState {
  free(): void;
  constructor(syncMode: boolean, syncProgressHeight: number, syncTipHeight: number, synced: boolean);
  syncMode: boolean;
  syncProgressHeight: number;
  syncTipHeight: number;
  synced: boolean;
}
export class TransactionsInfo {
  free(): void;
  constructor(generatorRoot: Uint8Array, generatorRefsRoot: Uint8Array, aggregatedSignature: Signature, fees: bigint, cost: bigint, rewardClaimsIncorporated: Coin[]);
  generatorRoot: Uint8Array;
  generatorRefsRoot: Uint8Array;
  aggregatedSignature: Signature;
  fees: bigint;
  cost: bigint;
  rewardClaimsIncorporated: Coin[];
}
export class VDFInfo {
  free(): void;
  constructor(challenge: Uint8Array, numberOfIterations: bigint, output: Uint8Array);
  challenge: Uint8Array;
  numberOfIterations: bigint;
  output: Uint8Array;
}
export class VDFProof {
  free(): void;
  constructor(witnessType: number, witness: Uint8Array, normalizedToIdentity: boolean);
  witnessType: number;
  witness: Uint8Array;
  normalizedToIdentity: boolean;
}
export class Vault {
  free(): void;
  child(custodyHash: Uint8Array): Vault;
  constructor(coin: Coin, launcherId: Uint8Array, proof: LineageProof, custodyHash: Uint8Array);
  coin: Coin;
  launcherId: Uint8Array;
  proof: LineageProof;
  custodyHash: Uint8Array;
}
export class VaultMint {
  free(): void;
  constructor(vault: Vault, parentConditions: Program[]);
  vault: Vault;
  parentConditions: Program[];
}
